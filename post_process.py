import pandas as pd
import numpy as np
import argparse

def load_genetic_map(file:str)->pd.DataFrame:
    """Load genetic map file and return a dataframe with columns: 'pos' (bp), 'cM' (centiMorgan)"""
    df = pd.read_csv(file, sep=" ", comment="#", header=0, usecols=[0,2])
    return df

def interpol_gen_pos(x, genetic_map:pd.DataFrame):
    """Interpolate genetic positions (cM) for given physical positions (bp) using the genetic map dataframe"""
    return 0.01 * np.interp(x, genetic_map['position'], genetic_map['Genetic_Map(cM)'] )

def merge_segments(df:pd.DataFrame, max_gap=0, min_length_s=0, min_length_l=0, verbose=False) -> pd.DataFrame:
        """Merge adjacent ROH segments present in the `df` ROH dataframe.
        First remove segments shorter than `min_length_s` (in Morgans).
        Then merge consecutive segments if the gap between them is less than `max_gap` (in Morgans) and at least one of the segments is longer than `min_length_l` (in Morgans).
        """
        df = df[df['lengthM']>=min_length_s]
        df_sorted = df.sort_values(by=["iid", "ch", "StartM"]).reset_index(drop=True)

        ### Calculate Conditions
        merge = ((df_sorted['StartM'] - df_sorted['EndM'].shift(1) < max_gap)
                    & ((df_sorted['lengthM'] >= min_length_l) | (df_sorted['lengthM'].shift(1) >= min_length_l))
                    & (df_sorted['ch'] == df_sorted['ch'].shift(1))
                    & (df_sorted['iid'] == df_sorted['iid'].shift(1)))

        df_sorted['group'] = (~merge).cumsum()
        df_new = df_sorted.groupby('group').agg({
            'iid': 'first',
            'ch': 'first',
            'StartBP': 'first',
            'EndBP': 'last',
            'StartM': 'first',
            'EndM': 'last'
        }).reset_index(drop=True)
        df_new['length'] = df_new['EndBP'] - df_new['StartBP']
        df_new['lengthM'] = df_new['EndM'] - df_new['StartM']

        df_new.reset_index(drop=True, inplace=True)

        if verbose == True:
            print(f"Merged n={len(df) - len(df_new)} gaps < {100*max_gap} cM")
        return df_new

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Postproccess output from bcftools roh to add genetic positions, filter out short ROH and merge close ROH")
    parser.add_argument("-i", "--input", help="Path to input file (as generated by bcftools roh --output-type r)", required=True)
    parser.add_argument("-o", "--output", help="Output folder", default="./")
    parser.add_argument("-m", "--genetic_map", help="Path to genetic map (as required by bcftools-roh)", default=None)

    # parse arguments
    args = parser.parse_args()
    infile = args.input
    output_file = args.output if args.output else infile.split(".")[0] + ".roh.csv"
    output_file_merged = args.output_proccesse if args.output_proccesse else infile.split(".")[0] + ".roh.merged.csv"
    genetic_map_file = args.genetic_map if args.genetic_map else "./genetic_map/chr{CHROM}.txt"

    # read roh file
    df = pd.read_csv(infile, sep="\t", skiprows=4, names=["trash", "iid", "ch", "StartBP", "EndBP", "length", "nb_marquers", "score"], index_col=False, usecols=[1,2,3,4])
    df['StartM'] = np.nan
    df['EndM'] = np.nan
    df['lengthM'] = np.nan

    # add genetic positions
    for chr in range(1, 21):
        genetic_map = load_genetic_map(genetic_map_file.format(CHROM=chr))

        df_chr = df.loc[df['ch'] == chr]

        df.loc[df['ch'] == chr, 'StartM'] = interpol_gen_pos(df_chr['StartBP'], genetic_map)
        df.loc[df['ch'] == chr, 'EndM'] = interpol_gen_pos(df_chr['EndBP'], genetic_map)
        df.loc[df['ch'] == chr, 'lengthM'] = df.loc[df['ch'] == chr, 'EndM'] - df.loc[df['ch'] == chr, 'StartM']

    df.to_csv(output_file, index=False)

    # merge close ROHs & filtering out short ROHs
    df_merged = merge_segments(df, max_gap=0.01, min_length_s=0.005, min_length_l=0.005, verbose=True)
    df_merged = df_merged[df_merged['lengthM'] > 0.04]

    df_merged.to_csv(output_file_merged, index=False)